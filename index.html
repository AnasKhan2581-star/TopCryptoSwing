<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout Trading Setup Provider</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2332 100%);
            color: #e8eaed;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(26, 35, 50, 0.8);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #f7931a, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(26, 35, 50, 0.6);
            border-radius: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }

        select, input, button {
            padding: 10px 15px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #1a2332;
            color: #e8eaed;
            font-size: 14px;
        }

        button {
            background: linear-gradient(45deg, #f7931a, #ffd700);
            color: #000;
            cursor: pointer;
            font-weight: bold;
            border: none;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(247, 147, 26, 0.4);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(26, 35, 50, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #333;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #f7931a;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        .coins-container {
            background: rgba(26, 35, 50, 0.8);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #333;
        }

        .coins-header {
            display: grid;
            grid-template-columns: 60px 100px 80px 100px 120px 120px 100px 100px 1fr;
            gap: 15px;
            padding: 15px;
            background: #1a2332;
            border-radius: 8px;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 12px;
            color: #888;
        }

        .coin-item {
            display: grid;
            grid-template-columns: 60px 100px 80px 100px 120px 120px 100px 100px 1fr;
            gap: 15px;
            padding: 15px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            transition: all 0.3s ease;
            align-items: center;
        }

        .coin-item:hover {
            background: rgba(247, 147, 26, 0.1);
            transform: translateX(5px);
        }

        .coin-symbol {
            font-weight: bold;
            color: #f7931a;
        }

        .coin-price {
            color: #4caf50;
        }

        .coin-change {
            font-weight: bold;
        }

        .positive {
            color: #4caf50;
        }

        .negative {
            color: #f44336;
        }

        .breakout-score {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
        }

        .score-high {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        .score-medium {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }

        .score-low {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: #1a2332;
            margin: 2% auto;
            padding: 0;
            border-radius: 15px;
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #333;
            background: linear-gradient(45deg, #f7931a, #ffd700);
            color: #000;
            border-radius: 15px 15px 0 0;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 24px;
        }

        .close {
            color: #000;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background 0.3s ease;
        }

        .close:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .modal-body {
            padding: 20px;
        }

        .analysis-section {
            margin-bottom: 30px;
        }

        .analysis-section h3 {
            color: #f7931a;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .analysis-card {
            background: rgba(15, 20, 25, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .indicator-value {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .indicator-label {
            font-size: 12px;
            color: #888;
        }

        .order-form {
            background: rgba(15, 20, 25, 0.8);
            padding: 25px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #f7931a;
            font-weight: bold;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .risk-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .risk-metric {
            text-align: center;
            padding: 15px;
            background: rgba(26, 35, 50, 0.6);
            border-radius: 8px;
            border: 1px solid #333;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #f7931a;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .chart-container {
            background: #0f1419;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .resistance-levels {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .resistance-level {
            padding: 5px 10px;
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
            border-radius: 5px;
            font-size: 12px;
            color: #f44336;
        }

        .support-level {
            padding: 5px 10px;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4caf50;
            border-radius: 5px;
            font-size: 12px;
            color: #4caf50;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .coins-header, .coin-item {
                grid-template-columns: 1fr;
                gap: 5px;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Breakout Trading Setup Provider</h1>
            <p>Real-time Binance data with advanced technical analysis for breakout opportunities</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Timeframe</label>
                <select id="timeframe">
                    <option value="1h">1 Hour</option>
                    <option value="4h" selected>4 Hours</option>
                    <option value="1d">1 Day</option>
                    <option value="3d">3 Days</option>
                    <option value="1w">1 Week</option>
                </select>
            </div>
            <div class="control-group">
                <label>Min Volume (USDT)</label>
                <input type="number" id="minVolume" value="1000000" placeholder="1,000,000">
            </div>
            <div class="control-group">
                <label>Min Price Change %</label>
                <input type="number" id="minChange" value="2" step="0.1" placeholder="2.0">
            </div>
            <button onclick="fetchData()">🔄 Refresh Data</button>
            <button onclick="startAutoRefresh()">⚡ Auto Refresh</button>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="totalCoins">0</div>
                <div class="stat-label">Total Coins</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="breakoutCandidates">0</div>
                <div class="stat-label">Breakout Candidates</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgVolume">0</div>
                <div class="stat-label">Avg Volume (24h)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="lastUpdate">--</div>
                <div class="stat-label">Last Update</div>
            </div>
        </div>

        <div class="coins-container">
            <div class="coins-header">
                <div>Rank</div>
                <div>Symbol</div>
                <div>Price</div>
                <div>Change 24h</div>
                <div>Volume 24h</div>
                <div>Avg Volume</div>
                <div>Market Cap</div>
                <div>Breakout Score</div>
                <div>Indicators</div>
            </div>
            <div id="coinsData" class="loading">
                <div class="spinner"></div>
                <div>Loading market data...</div>
            </div>
        </div>
    </div>

    <!-- Modal for detailed analysis -->
    <div id="analysisModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Detailed Analysis</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="analysis-section">
                    <h3>📊 Technical Analysis</h3>
                    <div class="analysis-grid">
                        <div class="analysis-card">
                            <div class="indicator-value" id="rsi">--</div>
                            <div class="indicator-label">RSI (14)</div>
                        </div>
                        <div class="analysis-card">
                            <div class="indicator-value" id="macd">--</div>
                            <div class="indicator-label">MACD Signal</div>
                        </div>
                        <div class="analysis-card">
                            <div class="indicator-value" id="bb">--</div>
                            <div class="indicator-label">Bollinger Bands</div>
                        </div>
                        <div class="analysis-card">
                            <div class="indicator-value" id="volumeProfile">--</div>
                            <div class="indicator-label">Volume Profile</div>
                        </div>
                        <div class="analysis-card">
                            <div class="indicator-value" id="supportResistance">--</div>
                            <div class="indicator-label">Support/Resistance</div>
                        </div>
                        <div class="analysis-card">
                            <div class="indicator-value" id="breakoutProbability">--</div>
                            <div class="indicator-label">Breakout Probability</div>
                        </div>
                    </div>
                </div>

                <div class="analysis-section">
                    <h3>📈 Key Levels</h3>
                    <div class="chart-container">
                        <div>Current Price: <span id="currentPrice">--</span></div>
                        <div>Resistance Levels:</div>
                        <div class="resistance-levels" id="resistanceLevels"></div>
                        <div>Support Levels:</div>
                        <div class="resistance-levels" id="supportLevels"></div>
                    </div>
                </div>

                <div class="analysis-section">
                    <h3>⚡ OCO Order Setup</h3>
                    <div class="order-form">
                        <div class="form-row">
                            <div class="form-group">
                                <label>Entry Price</label>
                                <input type="number" id="entryPrice" step="0.00001">
                            </div>
                            <div class="form-group">
                                <label>Quantity</label>
                                <input type="number" id="quantity" step="0.001">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Take Profit</label>
                                <input type="number" id="takeProfit" step="0.00001">
                            </div>
                            <div class="form-group">
                                <label>Stop Loss</label>
                                <input type="number" id="stopLoss" step="0.00001">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Risk %</label>
                                <input type="number" id="riskPercent" value="2" step="0.1" min="0.1" max="10">
                            </div>
                            <div class="form-group">
                                <label>R:R Ratio</label>
                                <input type="number" id="rrRatio" value="2" step="0.1" min="1">
                            </div>
                        </div>
                        <button onclick="calculateRisk()">📊 Calculate Risk</button>
                        <button onclick="generateOrder()">📋 Generate Order</button>
                        
                        <div class="risk-metrics">
                            <div class="risk-metric">
                                <div class="indicator-value" id="potentialLoss">$0</div>
                                <div class="indicator-label">Potential Loss</div>
                            </div>
                            <div class="risk-metric">
                                <div class="indicator-value" id="potentialProfit">$0</div>
                                <div class="indicator-label">Potential Profit</div>
                            </div>
                            <div class="risk-metric">
                                <div class="indicator-value" id="riskReward">1:1</div>
                                <div class="indicator-label">Risk:Reward</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let coinData = [];
        let autoRefreshInterval;
        let currentSymbol = '';

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            fetchData();
        });

        // Fetch data from Binance API
        async function fetchData() {
            try {
                document.getElementById('coinsData').innerHTML = '<div class="loading"><div class="spinner"></div><div>Loading market data...</div></div>';
                
                // Fetch 24hr ticker data
                const tickerResponse = await fetch('https://api.binance.com/api/v3/ticker/24hr');
                const tickerData = await tickerResponse.json();
                
                // Filter USDT pairs and sort by volume
                const usdtPairs = tickerData
                    .filter(coin => coin.symbol.endsWith('USDT'))
                    .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
                    .slice(0, 200);

                // Process and analyze each coin
                const processedData = await Promise.all(
                    usdtPairs.map(async (coin, index) => {
                        const analysis = await performTechnicalAnalysis(coin);
                        return {
                            ...coin,
                            rank: index + 1,
                            marketCap: calculateMarketCap(coin),
                            avgVolume: calculateAvgVolume(coin),
                            breakoutScore: analysis.breakoutScore,
                            indicators: analysis.indicators
                        };
                    })
                );

                coinData = processedData;
                displayCoins(coinData);
                updateStats(coinData);
                
            } catch (error) {
                console.error('Error fetching data:', error);
                document.getElementById('coinsData').innerHTML = '<div class="loading">Error loading data. Please try again.</div>';
            }
        }

        // Perform technical analysis on a coin
        async function performTechnicalAnalysis(coin) {
            try {
                const timeframe = document.getElementById('timeframe').value;
                const symbol = coin.symbol;
                
                // Fetch kline data
                const klineResponse = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${timeframe}&limit=100`);
                const klineData = await klineResponse.json();
                
                const closes = klineData.map(k => parseFloat(k[4]));
                const volumes = klineData.map(k => parseFloat(k[5]));
                const highs = klineData.map(k => parseFloat(k[2]));
                const lows = klineData.map(k => parseFloat(k[3]));
                
                // Calculate indicators
                const rsi = calculateRSI(closes);
                const macd = calculateMACD(closes);
                const bb = calculateBollingerBands(closes);
                const volumeProfile = calculateVolumeProfile(volumes);
                const supportResistance = findSupportResistance(highs, lows);
                
                // Calculate breakout probability
                const breakoutScore = calculateBreakoutScore({
                    rsi: rsi[rsi.length - 1],
                    macd: macd[macd.length - 1],
                    bb: bb[bb.length - 1],
                    volumeProfile,
                    supportResistance,
                    priceChange: parseFloat(coin.priceChangePercent)
                });

                return {
                    breakoutScore,
                    indicators: {
                        rsi: rsi[rsi.length - 1],
                        macd: macd[macd.length - 1],
                        bb: bb[bb.length - 1],
                        volumeProfile,
                        supportResistance
                    }
                };
            } catch (error) {
                console.error(`Error analyzing ${coin.symbol}:`, error);
                return { breakoutScore: 0, indicators: {} };
            }
        }

        // Calculate RSI
        function calculateRSI(closes, period = 14) {
            const gains = [];
            const losses = [];
            
            for (let i = 1; i < closes.length; i++) {
                const change = closes[i] - closes[i - 1];
                gains.push(change > 0 ? change : 0);
                losses.push(change < 0 ? Math.abs(change) : 0);
            }
            
            const rsi = [];
            for (let i = period - 1; i < gains.length; i++) {
                const avgGain = gains.slice(i - period + 1, i + 1).reduce((a, b) => a + b) / period;
                const avgLoss = losses.slice(i - period + 1, i + 1).reduce((a, b) => a + b) / period;
                
                if (avgLoss === 0) {
                    rsi.push(100);
                } else {
                    const rs = avgGain / avgLoss;
                    rsi.push(100 - (100 / (1 + rs)));
                }
            }
            
            return rsi;
        }

        // Calculate MACD
        function calculateMACD(closes) {
            const ema12 = calculateEMA(closes, 12);
            const ema26 = calculateEMA(closes, 26);
            const macd = ema12.map((val, i) => val - ema26[i]);
            const signal = calculateEMA(macd, 9);
            
            return macd.map((val, i) => val - signal[i]);
        }

        // Calculate EMA
        function calculateEMA(data, period) {
            const ema = [];
            const multiplier = 2 / (period + 1);
            
            ema[0] = data[0];
            for (let i = 1; i < data.length; i++) {
                ema[i] = (data[i] - ema[i - 1]) * multiplier + ema[i - 1];
            }
            
            return ema;
        }

        // Calculate Bollinger Bands
        function calculateBollingerBands(closes, period = 20) {
            const sma = calculateSMA(closes, period);
            const std = calculateStandardDeviation(closes, period);
            
            return sma.map((val, i) => ({
                upper: val + (std[i] * 2),
                middle: val,
                lower: val - (std[i] * 2),
                position: closes[i + period - 1] > val + (std[i] * 2) ? 'above' : 
                         closes[i + period - 1] < val - (std[i] * 2) ? 'below' : 'middle'
            }));
        }

        // Calculate SMA
        function calculateSMA(data, period) {
            const sma = [];
            for (let i = period - 1; i < data.length; i++) {
                const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b);
                sma.push(sum / period);
            }
            return sma;
        }

        // Calculate Standard Deviation
        function calculateStandardDeviation(data, period) {
            const sma = calculateSMA(data, period);
            const std = [];
            
            for (let i = period - 1; i < data.length; i++) {
                const slice = data.slice(i - period + 1, i + 1);
                const mean = sma[i - period + 1];
                const variance = slice.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / period;
                std.push(Math.sqrt(variance));
            }
            
            return std;
        }

        // Calculate Volume Profile
        function calculateVolumeProfile(volumes) {
            const recent = volumes.slice(-20);
            const average = recent.reduce((a, b) => a + b) / recent.length;
            const latest = volumes[volumes.length - 1];
            
            return {
                current: latest,
                average: average,
                ratio: latest / average,
                trend: latest > average ? 'increasing' : 'decreasing'
            };
        }

        // Find Support and Resistance levels
        function findSupportResistance(highs, lows) {
            const levels = [];
            
            // Find local highs and lows
            for (let i = 2; i < highs.length - 2; i++) {
                if (highs[i] > highs[i-1] && highs[i] > highs[i+1] && 
                    highs[i] > highs[i-2] && highs[i] > highs[i+2]) {
                    levels.push({ price: highs[i], type: 'resistance', strength: 1 });
                }
                
                if (lows[i] < lows[i-1] && lows[i] < lows[i+1] && 
                    lows[i] < lows[i-2] && lows[i] < lows[i+2]) {
                    levels.push({ price: lows[i], type: 'support', strength: 1 });
                }
            }
            
            // Group similar levels and calculate strength
            const groupedLevels = [];
            levels.forEach(level => {
                const existing = groupedLevels.find(l => 
                    Math.abs(l.price - level.price) / level.price < 0.005
                );
                
                if (existing) {
                    existing.strength++;
                } else {
                    groupedLevels.push(level);
                }
            });
            
            return groupedLevels.sort((a, b) => b.strength - a.strength).slice(0, 5);
        }

        // Calculate breakout score
        function calculateBreakoutScore(indicators) {
            let score = 0;
            
            // RSI check (ideal range 50-70 for bullish breakout)
            if (indicators.rsi > 50 && indicators.rsi < 70) score += 20;
            else if (indicators.rsi > 70) score += 10;
            
            // MACD check (positive for bullish)
            if (indicators.macd > 0) score += 20;
            
            // Bollinger Bands check
            if (indicators.bb && indicators.bb.position === 'above') score += 15;
            else if (indicators.bb && indicators.bb.position === 'middle') score += 10;
            
            // Volume check
            if (indicators.volumeProfile.ratio > 1.5) score += 25;
            else if (indicators.volumeProfile.ratio > 1.2) score += 15;
            
            // Price change check
            if (indicators.priceChange > 5) score += 20;
            else if (indicators.priceChange > 2) score += 10;
            
            return Math.min(score, 100);
        }

        // Calculate market cap (simplified)
        function calculateMarketCap(coin) {
            // This is a simplified calculation - actual market cap would need supply data
            const price = parseFloat(coin.lastPrice);
            const volume = parseFloat(coin.quoteVolume);
            return volume * 24; // Rough estimation
        }

        // Calculate average volume
        function calculateAvgVolume(coin) {
            return parseFloat(coin.quoteVolume);
        }

        // Display coins in the table
        function displayCoins(coins) {
            const container = document.getElementById('coinsData');
            container.innerHTML = '';
            
            coins.forEach(coin => {
                const changeClass = parseFloat(coin.priceChangePercent) >= 0 ? 'positive' : 'negative';
                const scoreClass = coin.breakoutScore >= 70 ? 'score-high' : 
                                 coin.breakoutScore >= 50 ? 'score-medium' : 'score-low';
                
                const coinElement = document.createElement('div');
                coinElement.className = 'coin-item';
                coinElement.onclick = () => openAnalysisModal(coin);
                
                coinElement.innerHTML = `
                    <div>${coin.rank}</div>
                    <div class="coin-symbol">${coin.symbol.replace('USDT', '')}</div>
                    <div class="coin-price">${parseFloat(coin.lastPrice).toFixed(6)}</div>
                    <div class="coin-change ${changeClass}">${parseFloat(coin.priceChangePercent).toFixed(2)}%</div>
                    <div>${formatNumber(coin.quoteVolume)}</div>
                    <div>${formatNumber(coin.avgVolume)}</div>
                    <div>${formatNumber(coin.marketCap)}</div>
                    <div class="breakout-score ${scoreClass}">${coin.breakoutScore}%</div>
                    <div>${getIndicatorSummary(coin.indicators)}</div>
                `;
                
                container.appendChild(coinElement);
            });
        }

        // Format large numbers
        function formatNumber(num) {
            const value = parseFloat(num);
            if (value >= 1e9) return (value / 1e9).toFixed(2) + 'B';
            if (value >= 1e6) return (value / 1e6).toFixed(2) + 'M';
            if (value >= 1e3) return (value / 1e3).toFixed(2) + 'K';
            return value.toFixed(2);
        }

        // Get indicator summary
        function getIndicatorSummary(indicators) {
            const signals = [];
            
            if (indicators.rsi > 70) signals.push('🔴 RSI High');
            else if (indicators.rsi > 50) signals.push('🟡 RSI Bullish');
            else if (indicators.rsi < 30) signals.push('🟢 RSI Low');
            
            if (indicators.macd > 0) signals.push('📈 MACD+');
            else signals.push('📉 MACD-');
            
            if (indicators.volumeProfile.ratio > 1.5) signals.push('🔊 Vol High');
            else if (indicators.volumeProfile.ratio > 1.2) signals.push('🔉 Vol+');
            
            return signals.slice(0, 3).join(' ');
        }

        // Update statistics
        function updateStats(coins) {
            const breakoutCandidates = coins.filter(coin => coin.breakoutScore >= 70).length;
            const totalVolume = coins.reduce((sum, coin) => sum + parseFloat(coin.quoteVolume), 0);
            const avgVolume = totalVolume / coins.length;
            
            document.getElementById('totalCoins').textContent = coins.length;
            document.getElementById('breakoutCandidates').textContent = breakoutCandidates;
            document.getElementById('avgVolume').textContent = formatNumber(avgVolume);
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        // Open analysis modal
        async function openAnalysisModal(coin) {
            currentSymbol = coin.symbol;
            document.getElementById('modalTitle').textContent = `${coin.symbol} - Breakout Analysis`;
            document.getElementById('analysisModal').style.display = 'block';
            
            // Populate technical indicators
            document.getElementById('rsi').textContent = coin.indicators.rsi ? coin.indicators.rsi.toFixed(2) : '--';
            document.getElementById('macd').textContent = coin.indicators.macd ? coin.indicators.macd.toFixed(4) : '--';
            document.getElementById('bb').textContent = coin.indicators.bb ? coin.indicators.bb.position : '--';
            document.getElementById('volumeProfile').textContent = coin.indicators.volumeProfile ? 
                coin.indicators.volumeProfile.ratio.toFixed(2) + 'x' : '--';
            document.getElementById('supportResistance').textContent = coin.indicators.supportResistance ? 
                coin.indicators.supportResistance.length + ' levels' : '--';
            document.getElementById('breakoutProbability').textContent = coin.breakoutScore + '%';
            
            // Populate price and levels
            document.getElementById('currentPrice').textContent = ' + parseFloat(coin.lastPrice).toFixed(6);
            
            // Display support and resistance levels
            const resistanceLevels = document.getElementById('resistanceLevels');
            const supportLevels = document.getElementById('supportLevels');
            
            resistanceLevels.innerHTML = '';
            supportLevels.innerHTML = '';
            
            if (coin.indicators.supportResistance) {
                coin.indicators.supportResistance.forEach(level => {
                    const levelElement = document.createElement('div');
                    levelElement.className = level.type === 'resistance' ? 'resistance-level' : 'support-level';
                    levelElement.textContent = `${level.price.toFixed(6)} (${level.strength}x)`;
                    
                    if (level.type === 'resistance') {
                        resistanceLevels.appendChild(levelElement);
                    } else {
                        supportLevels.appendChild(levelElement);
                    }
                });
            }
            
            // Auto-fill order form
            await setupOrderForm(coin);
        }

        // Setup order form with calculated values
        async function setupOrderForm(coin) {
            const currentPrice = parseFloat(coin.lastPrice);
            const resistance = coin.indicators.supportResistance?.find(l => l.type === 'resistance');
            const support = coin.indicators.supportResistance?.find(l => l.type === 'support');
            
            // Calculate entry price (slightly above current price for breakout)
            const entryPrice = resistance ? resistance.price * 1.002 : currentPrice * 1.005;
            
            // Calculate take profit (next resistance or 1:2 risk reward)
            const takeProfit = entryPrice * 1.06; // 6% profit target
            
            // Calculate stop loss (below support or 2% below entry)
            const stopLoss = support ? support.price * 0.998 : entryPrice * 0.98;
            
            document.getElementById('entryPrice').value = entryPrice.toFixed(6);
            document.getElementById('takeProfit').value = takeProfit.toFixed(6);
            document.getElementById('stopLoss').value = stopLoss.toFixed(6);
            
            // Calculate suggested quantity based on risk
            calculateRisk();
        }

        // Calculate risk metrics
        function calculateRisk() {
            const entryPrice = parseFloat(document.getElementById('entryPrice').value) || 0;
            const takeProfit = parseFloat(document.getElementById('takeProfit').value) || 0;
            const stopLoss = parseFloat(document.getElementById('stopLoss').value) || 0;
            const quantity = parseFloat(document.getElementById('quantity').value) || 0;
            const riskPercent = parseFloat(document.getElementById('riskPercent').value) || 2;
            
            if (entryPrice > 0 && takeProfit > 0 && stopLoss > 0) {
                const potentialLoss = (entryPrice - stopLoss) * quantity;
                const potentialProfit = (takeProfit - entryPrice) * quantity;
                const riskReward = potentialProfit / potentialLoss;
                
                document.getElementById('potentialLoss').textContent = ' + potentialLoss.toFixed(2);
                document.getElementById('potentialProfit').textContent = ' + potentialProfit.toFixed(2);
                document.getElementById('riskReward').textContent = '1:' + riskReward.toFixed(2);
                
                // Update R:R ratio input
                document.getElementById('rrRatio').value = riskReward.toFixed(2);
                
                // Suggest quantity based on risk percentage
                if (quantity === 0) {
                    const accountBalance = 10000; // Assume $10,000 account
                    const riskAmount = accountBalance * (riskPercent / 100);
                    const priceRisk = entryPrice - stopLoss;
                    const suggestedQuantity = riskAmount / priceRisk;
                    
                    document.getElementById('quantity').value = suggestedQuantity.toFixed(6);
                }
            }
        }

        // Generate OCO order
        function generateOrder() {
            const entryPrice = document.getElementById('entryPrice').value;
            const takeProfit = document.getElementById('takeProfit').value;
            const stopLoss = document.getElementById('stopLoss').value;
            const quantity = document.getElementById('quantity').value;
            
            const orderData = {
                symbol: currentSymbol,
                side: 'BUY',
                type: 'OCO',
                quantity: quantity,
                price: entryPrice,
                stopPrice: stopLoss,
                stopLimitPrice: stopLoss,
                stopLimitTimeInForce: 'GTC',
                listClientOrderId: 'breakout_' + Date.now()
            };
            
            // Create order summary
            const orderSummary = `
🚀 BREAKOUT TRADE SETUP - ${currentSymbol}
═══════════════════════════════════════

📊 ENTRY DETAILS:
• Symbol: ${currentSymbol}
• Entry Price: ${entryPrice}
• Quantity: ${quantity}
• Order Type: OCO (One-Cancels-Other)

🎯 TARGETS:
• Take Profit: ${takeProfit}
• Stop Loss: ${stopLoss}
• Risk/Reward: 1:${document.getElementById('rrRatio').value}

💰 RISK MANAGEMENT:
• Potential Loss: ${document.getElementById('potentialLoss').textContent}
• Potential Profit: ${document.getElementById('potentialProfit').textContent}
• Risk Percentage: ${document.getElementById('riskPercent').value}%

⚠️ TRADING NOTES:
• Wait for breakout confirmation above resistance
• Monitor volume for strength validation
• Consider market conditions and overall trend
• Never risk more than you can afford to lose

🔗 BINANCE API ORDER (TEST):
${JSON.stringify(orderData, null, 2)}

═══════════════════════════════════════
Generated on: ${new Date().toLocaleString()}
            `;
            
            // Create and download order file
            const blob = new Blob([orderSummary], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `breakout_setup_${currentSymbol}_${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            alert('Order setup generated and downloaded! Please review carefully before placing actual trades.');
        }

        // Close modal
        function closeModal() {
            document.getElementById('analysisModal').style.display = 'none';
        }

        // Auto refresh functionality
        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                document.querySelector('[onclick="startAutoRefresh()"]').textContent = '⚡ Auto Refresh';
            } else {
                autoRefreshInterval = setInterval(fetchData, 30000); // Refresh every 30 seconds
                document.querySelector('[onclick="startAutoRefresh()"]').textContent = '⏹️ Stop Auto';
            }
        }

        // Event listeners
        document.getElementById('timeframe').addEventListener('change', fetchData);
        document.getElementById('minVolume').addEventListener('change', filterCoins);
        document.getElementById('minChange').addEventListener('change', filterCoins);

        // Form event listeners
        document.getElementById('entryPrice').addEventListener('input', calculateRisk);
        document.getElementById('takeProfit').addEventListener('input', calculateRisk);
        document.getElementById('stopLoss').addEventListener('input', calculateRisk);
        document.getElementById('quantity').addEventListener('input', calculateRisk);
        document.getElementById('riskPercent').addEventListener('input', calculateRisk);

        // Filter coins based on criteria
        function filterCoins() {
            const minVolume = parseFloat(document.getElementById('minVolume').value) || 0;
            const minChange = parseFloat(document.getElementById('minChange').value) || 0;
            
            const filteredCoins = coinData.filter(coin => {
                const volume = parseFloat(coin.quoteVolume);
                const change = Math.abs(parseFloat(coin.priceChangePercent));
                return volume >= minVolume && change >= minChange;
            });
            
            displayCoins(filteredCoins);
            updateStats(filteredCoins);
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('analysisModal');
            if (event.target === modal) {
                closeModal();
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeModal();
            }
            if (event.key === 'F5') {
                event.preventDefault();
                fetchData();
            }
        });

        // Additional utility functions
        function getMarketSentiment() {
            const bullishCoins = coinData.filter(coin => parseFloat(coin.priceChangePercent) > 0).length;
            const totalCoins = coinData.length;
            return (bullishCoins / totalCoins * 100).toFixed(1);
        }

        function getTopPerformers() {
            return coinData
                .filter(coin => coin.breakoutScore >= 70)
                .sort((a, b) => b.breakoutScore - a.breakoutScore)
                .slice(0, 10);
        }

        function getHighVolumeCoins() {
            return coinData
                .filter(coin => coin.indicators.volumeProfile?.ratio > 2)
                .sort((a, b) => b.indicators.volumeProfile.ratio - a.indicators.volumeProfile.ratio)
                .slice(0, 10);
        }

        // Initialize tooltips and help text
        function initializeHelp() {
            const helpTexts = {
                'rsi': 'RSI > 70 is overbought, < 30 is oversold. Ideal breakout range: 50-70',
                'macd': 'MACD above 0 indicates bullish momentum',
                'bb': 'Price above upper band suggests strong bullish momentum',
                'volumeProfile': 'Volume ratio > 1.5x indicates strong interest',
                'breakoutScore': 'Composite score based on multiple technical indicators'
            };
            
            Object.keys(helpTexts).forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.title = helpTexts[id];
                }
            });
        }

        // Error handling for API failures
        function handleApiError(error) {
            console.error('API Error:', error);
            const errorMessage = error.message || 'Unknown error occurred';
            
            if (errorMessage.includes('429')) {
                alert('Rate limit exceeded. Please wait a moment before refreshing.');
            } else if (errorMessage.includes('network')) {
                alert('Network error. Please check your internet connection.');
            } else {
                alert('API error: ' + errorMessage);
            }
        }

        // Performance monitoring
        function logPerformance(action, startTime) {
            const endTime = Date.now();
            const duration = endTime - startTime;
            console.log(`Performance: ${action} took ${duration}ms`);
        }

        // Initialize help system
        setTimeout(initializeHelp, 1000);
    </script>
</body>
</html>
